[{"content":"Recently, I\u0026rsquo;ve been doing a lot of work learning about AI and neural networks‚Äìspecifically by creating deep learning models from scratch. So, I thought I\u0026rsquo;d document some of that learning in a multi-part series about deep learning.\nIn case you\u0026rsquo;re not already familiar, neural networks are AI processes that are modeled after the human brain and can solve problems by simulating human methods of learning.\nFor example, in the same way that your brain has learned to differentiate between cats and dogs, we can also teach a neural network to classify types of pets (among other things).\nBut how is a computer able to learn like a person? Well, let\u0026rsquo;s first look at one of the most essential building blocks of the human brain:\nImage courtesy of https://www.simplypsychology.org/neuron.html\nAs you can see, this is a model of a neuron. For our purposes, we\u0026rsquo;ll mostly focus on the dendrites and axons of the neuron.\nIn your brain, neurons link together to form neuron chains, which propagate chemical signals from neuron to neuron. These chemical signals are what ultimately determine whether or not certain neurons fire.\nIn order to form these chains, the dendrites of one neuron connect to the axons of another (via axon terminals) over a space called a synapse. By connecting these ends, you can see how neurons can be strung together to form really long chain chains.\nIt\u0026rsquo;s kind of like plugging extension cords into each other:\nUsing the extension cord example, it\u0026rsquo;s easy to see how a lot of neurons could be connected together (billions of \u0026rsquo;em) and how they can fire in succession based on chemical signals that travel through the neuron chains.\nOk, so? In essence, a neural network tries to simulate these complex chains of neurons to make decisions like a human would.\nComputationally speaking, we can do this by representing neurons using code, and then simulating how neuron chains would fire to make a decision or judgment like a human brain.\nOf course, this is just a brief overview of the philosophy behind neural networks and it barely even scratches the surface of their complexity. Look out for Part 1 where I\u0026rsquo;ll go more in depth into the code required to create the foundation of a neural network.\n","permalink":"https://olinjohnson.github.io/posts/part-0-bits-and-brains/","summary":"Recently, I\u0026rsquo;ve been doing a lot of work learning about AI and neural networks‚Äìspecifically by creating deep learning models from scratch. So, I thought I\u0026rsquo;d document some of that learning in a multi-part series about deep learning.\nIn case you\u0026rsquo;re not already familiar, neural networks are AI processes that are modeled after the human brain and can solve problems by simulating human methods of learning.\nFor example, in the same way that your brain has learned to differentiate between cats and dogs, we can also teach a neural network to classify types of pets (among other things).","title":"Part 0: Bits and Brains?"},{"content":"When creating an AI for games like chess and Othello, your move generation function is one of the most integral parts of the algorithm. However, often times, (if you‚Äôre not careful) it can also be one of the slowest parts of your AI, often greatly impacting performance after being executed over and over, millions of times. It is the chink in the impenetrable armor of your DIY supercomputer.\nHowever, good news for you, there are significant optimizations we can make to drastically decrease the running time of your move generation function. One of the most influencing factors happens to be the way we represent the board.\nInstead of representing the board with something like a 2d array, there‚Äôs a much more efficient data structure we can use: a bitboard.\nActually, multiple bitboards.\nSee, it turns out that it is very efficient to represent the board simply as a collection of large numbers. A bitboard is usually just a 64 bit integer, with each bit representing the corresponding tile on a board like a chess board. For example, In the game Othello, we might have 2 bitboards ‚Äì 1 for black and another for white. Each ‚Äúon‚Äù bit, or 1, in a bitboard represents an occupied tile, where a player‚Äôs piece is. Each ‚Äúoff‚Äù bit, or 0, represents an empty tile. This is why we have a bitboard for both black and white, to distinguish between each player‚Äôs pieces.\nDefining a bitboard in C# can be as simple as declaring an unsigned (non-negative) long integer.\nulong bitboard = 0; In a game like Othello, we can also create a class for the game board with attributes to hold the bitboards for black and white.\nclass Board { ulong white_pieces = 0; ulong black_pieces = 0; public Board() { white_pieces = 0x1008000000; black_pieces = 0x810000000; } } Now, if we initialize a new Board, it will give us the starting position for an Othello game.\nYou can see that if you convert the values for white_pieces and black_pieces from hexadecimal to binary, the activated bits in each bitboard will match up with the positions of the pieces on the board.\nulong white_pieces = 0x1008000000; /* *\t0x1008000000 = 0001000000001000000000000000000000000000 * *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0 0 *\t0 0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 */ ulong black_pieces = 0x810000000; /* *\t0x810000000 = 100000010000000000000000000000000000 * *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 */ Why use bitboards? Well, I can assure you, though bitboards seem like a lot of hassle initially, they are well worth it for their performance benefits.\nThe primary reason why bitboards are so computationally efficient is because you can utilize bitwise operators to speed up calculation and eleminate conditionals.\nFor example, in the game connect 4, in order to detect a win, we need to evaluate if either player has 4 in a row.\nWe can start by initializing two bitboards, one to keep track of the red player‚Äôs pieces and another to keep track of the yellow player‚Äôs pieces. Since a connect 4 board is smaller (only 42 tiles), we only need 42 bits to represent the board. So, we‚Äôll assign each of the first 42 bits to a position on the board.\nulong red_pieces = 0; ulong yellow_pieces = 0; Now let‚Äôs assume the following board position:\nAs you can see in the above screenshot, yellow has won the game by placing 4 of their pieces vertically in a row.\nUsing a bitboard, we can check for a vertical win by utilizing the bitwise AND and bitshift operators as follows:\nulong pairs = yellow_pieces \u0026amp; (yellow_pieces \u0026lt;\u0026lt; 1); ulong quads = pairs \u0026amp; (pairs \u0026lt;\u0026lt; 2); if(quads \u0026gt; 0) { return true; } else { return false; } First of all, we start by initializing a new bitboard, called pairs.\nThe goal of this bitboard is to store all of the vertical pairs of yellow coins, all the 2-in-a-row combinations.\nTo do this, we first bitshift all the yellow pieces left 1 bit ‚Äì the upwards direction.\nAs you can see, bit 19 gets shifted to bit 20, bit 20 gets shifted to bit 21, bit 21 gets shifted to bit 22, and bit 22 gets shifted to bit 23.\nNow that we have shifted all of the pieces up by 1 tile, we record which pieces align with the initial yellow pieces. If they do align, then we have found 2 in a row.\nWe can do this by using the bitwise AND operator.\n/* *\t0 0 0 0 0 0 0\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t\u0026amp;\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 0 0 0 0 */ // 000000000000000000001111000000000000000000 \u0026amp; 000000000000000000011110000000000000000000 Bits 20, 21, and 22 are activated on both bitboards, so when we AND them together, those are the bits that will be left on.\n/* *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 */ // 000000000000000000001110000000000000000000 Since there are three activated bits, we can see that there were three pairs of vertical yellow pieces.\nNext, we‚Äôll repeat the whole process again to find 4 in a row ‚Äì with a slight tweak.\nThis time, we‚Äôre going to calculate a bitboard called quads ‚Äì we‚Äôll take the bitboard pairs that we just calculated and bitshift it left 2 bits. This is to find ‚Äúpairs of pairs‚Äù, or 4 in a row.\n// 000000000000000000001110000000000000000000 \u0026lt;\u0026lt; 2 /* * Result: * *\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 */ // 000000000000000000111000000000000000000000 Finally, we‚Äôll AND the result with pairs . If there are any bits left on after this operation, we‚Äôll know we have found four in a row.\n/* *\t0 0 0 1 0 0 0\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0\t\u0026amp;\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0\t0 0 0 0 0 0 0 */ // 000000000000000000111000000000000000000000 \u0026amp; 000000000000000000001110000000000000000000 Result:\n/* *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 */ // 000000000000000000001000000000000000000000 1 bit (that corresponds to the topmost yellow piece) has been left activated - this means that there we have found four in a row.\nTo calculate four in a row in other directions too, we can just change the amount bitshifted. For example, we could calculate horizontal wins by bitshifting 6 bits to the left, instead of 1.\nUsing bitboards, we are able to calculate wins in connect 4 (and many other applications) without the use of many conditionals and using very low-level operations. This makes bitboards remarkably fast ‚Äì good for an AI that needs to check for wins millions of times.\nBitboards can also be applied to more complex games like chess, where you can have a bitboard for each type of piece and color (i.e. A bitboard for white knights).\nCheck out my full Connect 4 AIand Othello AI.\n","permalink":"https://olinjohnson.github.io/posts/optimizing-chess-othello-and-connect-4-with-bitboards/","summary":"When creating an AI for games like chess and Othello, your move generation function is one of the most integral parts of the algorithm. However, often times, (if you‚Äôre not careful) it can also be one of the slowest parts of your AI, often greatly impacting performance after being executed over and over, millions of times. It is the chink in the impenetrable armor of your DIY supercomputer.\nHowever, good news for you, there are significant optimizations we can make to drastically decrease the running time of your move generation function.","title":"Optimizing Chess, Othello, and Connect 4 With Bitboards"},{"content":"For a long time now, I\u0026rsquo;ve always found it a little bit weird that in Minecraft, only the person who gets the last swipe on the ender dragon actually earns the advancement \u0026ldquo;Free the End\u0026rdquo;.\nSo, after a suggestion from a friend, I decided to code a little plugin that would grant the advancement to every player who was involved with the fight.\nCoding the Plugin Before starting, you\u0026rsquo;ll have to install a fantastic IntelliJ plugin called Minecraft Development, which will set up our project architecture very easily for us.\nWith the plugin installed, I fired up IntelliJ and created a new project. Then I selected minecraft, then spigot plugin, so the plugin would work on my spigot server.\nAfter that, you\u0026rsquo;ll need to enter a GroupId and ArtifactId.\nFirstly, your GroupId should be your domain name backwards. So, if you have an actual domain name, you can enter it like com.yourdomainname. However, if you don\u0026rsquo;t have a domain name, you can always use your github pages subdomain. For example, my GroupId was io.github.olinjohnson.\nThen, your ArtifactId should be whatever the name of your plugin is going to be.\nAfter that, you\u0026rsquo;ll have the option to enter some additional (but not required) information, then you can click Next again, name you project, and click Create.\nFinally, IntelliJ will open a window for you to begin developing your plugin.\nIn the project\u0026rsquo;s file architecture, there is a directory called src. Inside src -\u0026gt; main -\u0026gt; java there will be a java package with the title yourGroupId.yourArtifactId. Inside this package is where the core class for the project is. If we open up the java class, we can see a couple important methods.\npackage io.github.olinjohnson.fenderender; import org.bukkit.plugin.java.JavaPlugin; public final class FenderEnder extends JavaPlugin { @Override public void onEnable(){ } @Override public void onDisable() } } The onEnable() method is called when the plugin is loaded, and onDisable is called when the plugin is terminated.\nFor now, we\u0026rsquo;re going to leave these two methods alone and create a new class inside the package called EnderDragonController.\nMy original thought process for creating this plugin was that the plugin should start by containing an event listener for whenever any entity dies. Then, it should check if the recently deceased entity is the ender dragon. If so, then it should award the \u0026ldquo;Free the End\u0026rdquo; advancement to any player in the end dimension.\nSo, lets begin by creating the event listener. We\u0026rsquo;ll want our class EnderDragonController to implement the Bukkit Listener class.\npackage io.github.olinjohnson.fenderender; import org.bukkit.Bukkit; import org.bukkit.event.Listener; public class EnderDragonController implements Listener { } Then, we\u0026rsquo;ll create a method to listen for an entity death events.\npackage io.github.olinjohnson.fenderender; import org.bukkit.Bukkit; import org.bukkit.event.Listener; import org.bukkit.event.EventHandler; import org.bukkit.event.entity.EntityDeathEvent; public class EnderDragonController implements Listener { @EventHandler public void onEnderDragonDeath(EntityDeathEvent event){ } } However, right now, this method is called whenever any entity dies. We only want it to run when the ender dragon dies. So, we\u0026rsquo;ll add a check to see if it was the ender dragon that died.\npackage io.github.olinjohnson.fenderender; import org.bukkit.Bukkit; import org.bukkit.event.Listener; import org.bukkit.event.EventHandler; import org.bukkit.event.entity.EntityDeathEvent; import org.bukkit.entity.Entity; import org.bukkit.entity.EnderDragon; public class EnderDragonController implements Listener { @EventHandler public void onEnderDragonDeath(EntityDeathEvent event){ Entity entity = event.getEntity(); if(entity instanceof EnderDragon){ } } } In the code, we can use the instanceof keyword to compare the entity in question and check if it is the ender dragon. This checks to see if the entity is an instance of the EnderDragon class.\nNow that we\u0026rsquo;ve detected the death of the ender dragon, we need to reward all players in the end dimension with the advancement. We\u0026rsquo;ll start by retrieving a list of all the online players with Bukkit.getOnlinePlayers(). This returns a Java collection, which we can iterate over in a for loop.\npackage io.github.olinjohnson.fenderender; import org.bukkit.Bukkit; import org.bukkit.event.Listener; import org.bukkit.event.EventHandler; import org.bukkit.event.entity.EntityDeathEvent; import org.bukkit.entity.Entity; import org.bukkit.entity.EnderDragon; import org.bukkit.entity.Player; public class EnderDragonController implements Listener { @EventHandler public void onEnderDragonDeath(EntityDeathEvent event){ Entity entity = event.getEntity(); if(entity instanceof EnderDragon){ for(Player p: Bukkit.getOnlinePlayers()){ } } } } Then, we\u0026rsquo;ll add a check to see which players in the collection are in the end dimension.\npackage io.github.olinjohnson.fenderender; import org.bukkit.Bukkit; import org.bukkit.event.Listener; import org.bukkit.event.EventHandler; import org.bukkit.event.entity.EntityDeathEvent; import org.bukkit.entity.Entity; import org.bukkit.entity.EnderDragon; import org.bukkit.World; public class EnderDragonController implements Listener { @EventHandler public void onEnderDragonDeath(EntityDeathEvent event){ Entity entity = event.getEntity(); if(entity instanceof EnderDragon){ for(Player p: Bukkit.getOnlinePlayers()){ if(p.getWorld().getEnvironment() == World.Environment.THE_END){ } } } } } Finally, now that we\u0026rsquo;ve compiled a collection of players who were in the end while the ender dragon was killed, we need to reward them all with the advancement \u0026ldquo;Free the End\u0026rdquo;.\nWe\u0026rsquo;ll start by storing a reference to the advancement name in an instance of Bukkit\u0026rsquo;s NamespacedKey class. Then, we\u0026rsquo;ll get a reference to the player\u0026rsquo;s progress towards the advancement.\n// Reference to the advancement name NamespacedKey key = NamespacedKey.minecraft(\u0026#34;end/kill_dragon\u0026#34;); // Get the player\u0026#39;s current progress AdvancementProgress progress = p.getAdvancementProgress(Bukkit.getAdvancement(key)); Then, we\u0026rsquo;ll evaluate every remaining criteria that a player has to complete to fulfill this advancement. We\u0026rsquo;ll update any incomplete criteria to be complete.\n// Reference to the advancement name NamespacedKey key = NamespacedKey.minecraft(\u0026#34;end/kill_dragon\u0026#34;); // Get the player\u0026#39;s current progress AdvancementProgress progress = p.getAdvancementProgress(Bukkit.getAdvancement(key)); // Iterate over remaining criteria for(String stuff_left: progress.getRemainingCriteria()){ // Grant progress towards the advancement progress.awardCriteria(left); } This will award a player with the advancement.\nFinally, all your code in the EnderDragonController class should look similar to this:\npackage io.github.olinjohnson.fenderender; import org.bukkit.Bukkit; import org.bukkit.event.Listener; import org.bukkit.event.EventHandler; import org.bukkit.event.entity.EntityDeathEvent; import org.bukkit.entity.Entity; import org.bukkit.entity.EnderDragon; import org.bukkit.entity.Player; import org.bukkit.World; import org.bukkit.NamespacedKey; import org.bukkit.advancement.AdvancementProgress; public class EnderDragonController implements Listener { @EventHandler public void onEnderDragonDeath(EntityDeathEvent event){ Entity entity = event.getEntity(); if(entity instanceof EnderDragon){ for(Player p: Bukkit.getOnlinePlayers()){ if(p.getWorld().getEnvironment() == World.Environment.THE_END){ NamespacedKey key = NamespacedKey.minecraft(\u0026#34;end/kill_dragon\u0026#34;); AdvancementProgress progress = p.getAdvancementProgress(Bukkit.getAdvancement(key)); for(String stuff_left: progress.getRemainingCriteria()){ progress.awardCriteria(stuff_left); } } } } } } Alright! We\u0026rsquo;re almost done. Just one more small thing to do.\nNavigate back to your core class, the one with the same name as the title of your project.\nIn the onEnable() method, we need to initialize our EnderDragonController class, so it knows to actually listen for events.\npackage io.github.olinjohnson.fenderender; import org.bukkit.plugin.java.JavaPlugin; public final class FenderEnder extends JavaPlugin { @Override public void onEnable() { getServer().getPluginManager().registerEvents(new EnderDragonController(), this); } @Override public void onDisable() {} } Now we\u0026rsquo;re done!\nYou can package your plugin into a jar file by selecting Build -\u0026gt; Build Project, using CTRL + F9, or by running mvn package from the root level of your project.\nThis will create a jar file in your project\u0026rsquo;s target directory, which you can then import into your server\u0026rsquo;s plugins directory to see it in action!\nThe final code for this project can be viewed here on GitHub.\n","permalink":"https://olinjohnson.github.io/posts/code-for-an-ender-dragon-conquistador/","summary":"For a long time now, I\u0026rsquo;ve always found it a little bit weird that in Minecraft, only the person who gets the last swipe on the ender dragon actually earns the advancement \u0026ldquo;Free the End\u0026rdquo;.\nSo, after a suggestion from a friend, I decided to code a little plugin that would grant the advancement to every player who was involved with the fight.\nCoding the Plugin Before starting, you\u0026rsquo;ll have to install a fantastic IntelliJ plugin called Minecraft Development, which will set up our project architecture very easily for us.","title":"Code for an Ender Dragon Conquistador"},{"content":"Hello, world!\n","permalink":"https://olinjohnson.github.io/posts/my-first-post/","summary":"Hello, world!","title":"My First Post"},{"content":"Howdy, I\u0026rsquo;m Olin! I‚Äôm a web developer, AI enthusiast, and cybersecurity aficionado.\nA few things I like to do\u0026hellip;  I love coding - especially AI. I like CTFs. I started doing CTFs a while ago while on a mission to learn more about cybersecurity. I like making music. I like running and skiing.  A few projects I\u0026rsquo;ve completed\u0026hellip;  Othello clone with AI Connect 4 clone with AI Sudoku solver \u0026amp; generator Minesweeper clone 2048 clone   Contributed to numpy Contributed to matplotlib  What I\u0026rsquo;m currently working on\u0026hellip;  A mediocre chess engine A custom machine learning framework Open source projects  üì´ How to reach me: nervy.panoply.0w@icloud.com\n","permalink":"https://olinjohnson.github.io/about/","summary":"Howdy, I\u0026rsquo;m Olin! I‚Äôm a web developer, AI enthusiast, and cybersecurity aficionado.\nA few things I like to do\u0026hellip;  I love coding - especially AI. I like CTFs. I started doing CTFs a while ago while on a mission to learn more about cybersecurity. I like making music. I like running and skiing.  A few projects I\u0026rsquo;ve completed\u0026hellip;  Othello clone with AI Connect 4 clone with AI Sudoku solver \u0026amp; generator Minesweeper clone 2048 clone   Contributed to numpy Contributed to matplotlib  What I\u0026rsquo;m currently working on\u0026hellip;  A mediocre chess engine A custom machine learning framework Open source projects  üì´ How to reach me: nervy.","title":"About"},{"content":"","permalink":"https://olinjohnson.github.io/projects/","summary":"","title":"Past Projects"}]