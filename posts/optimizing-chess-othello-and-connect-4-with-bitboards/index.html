<!doctype html><html lang=en dir=" auto"><head><meta name=description content="Olin Johnson's personal programming blog"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimizing Chess, Othello, and Connect 4 With Bitboards | Olin Johnson</title><meta name=keywords content><meta name=description content="Using bitboards to speed up move generation and evaluation"><meta name=author content="Olin Johnson"><link rel=canonical href=https://olinjohnson.github.io/posts/optimizing-chess-othello-and-connect-4-with-bitboards/><link crossorigin=anonymous href=/assets/css/stylesheet.a8100acc2d207dcd0b9610c7a55d3f6c242324e6b51a6e7061eecea4c5cc7f29.css integrity="sha256-qBAKzC0gfc0LlhDHpV0/bCQjJOa1Gm5wYe7OpMXMfyk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://olinjohnson.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://olinjohnson.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://olinjohnson.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://olinjohnson.github.io/apple-touch-icon.png><link rel=mask-icon href=https://olinjohnson.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Optimizing Chess, Othello, and Connect 4 With Bitboards"><meta property="og:description" content="Using bitboards to speed up move generation and evaluation"><meta property="og:type" content="article"><meta property="og:url" content="https://olinjohnson.github.io/posts/optimizing-chess-othello-and-connect-4-with-bitboards/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-20T00:00:00+00:00"><meta property="og:site_name" content="Olin Johnson"><meta name=twitter:card content="summary"><meta name=twitter:title content="Optimizing Chess, Othello, and Connect 4 With Bitboards"><meta name=twitter:description content="Using bitboards to speed up move generation and evaluation"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://olinjohnson.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Optimizing Chess, Othello, and Connect 4 With Bitboards","item":"https://olinjohnson.github.io/posts/optimizing-chess-othello-and-connect-4-with-bitboards/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimizing Chess, Othello, and Connect 4 With Bitboards","name":"Optimizing Chess, Othello, and Connect 4 With Bitboards","description":"Using bitboards to speed up move generation and evaluation","keywords":[],"articleBody":"When creating an AI for games like chess and Othello, your move generation function is one of the most integral parts of the algorithm. However, often times, (if you’re not careful) it can also be one of the slowest parts of your AI, often greatly impacting performance after being executed over and over, millions of times. It is the chink in the impenetrable armor of your DIY supercomputer.\nHowever, good news for you, there are significant optimizations we can make to drastically decrease the running time of your move generation function. One of the most influencing factors happens to be the way we represent the board.\nInstead of representing the board with something like a 2d array, there’s a much more efficient data structure we can use: a bitboard.\nActually, multiple bitboards.\nSee, it turns out that it is very efficient to represent the board simply as a collection of large numbers. A bitboard is usually just a 64 bit integer, with each bit representing the corresponding tile on a board like a chess board. For example, In the game Othello, we might have 2 bitboards – 1 for black and another for white. Each “on” bit, or 1, in a bitboard represents an occupied tile, where a player’s piece is. Each “off” bit, or 0, represents an empty tile. This is why we have a bitboard for both black and white, to distinguish between each player’s pieces.\nDefining a bitboard in C# can be as simple as declaring an unsigned (non-negative) long integer.\nulong bitboard = 0; In a game like Othello, we can also create a class for the game board with attributes to hold the bitboards for black and white.\nclass Board { ulong white_pieces = 0; ulong black_pieces = 0; public Board() { white_pieces = 0x1008000000; black_pieces = 0x810000000; } } Now, if we initialize a new Board, it will give us the starting position for an Othello game.\nYou can see that if you convert the values for white_pieces and black_pieces from hexadecimal to binary, the activated bits in each bitboard will match up with the positions of the pieces on the board.\nulong white_pieces = 0x1008000000; /* *\t0x1008000000 = 0001000000001000000000000000000000000000 * *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0 0 *\t0 0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 */ ulong black_pieces = 0x810000000; /* *\t0x810000000 = 100000010000000000000000000000000000 * *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 0 */ Why use bitboards? Well, I can assure you, though bitboards seem like a lot of hassle initially, they are well worth it for their performance benefits.\nThe primary reason why bitboards are so computationally efficient is because you can utilize bitwise operators to speed up calculation and eleminate conditionals.\nFor example, in the game connect 4, in order to detect a win, we need to evaluate if either player has 4 in a row.\nWe can start by initializing two bitboards, one to keep track of the red player’s pieces and another to keep track of the yellow player’s pieces. Since a connect 4 board is smaller (only 42 tiles), we only need 42 bits to represent the board. So, we’ll assign each of the first 42 bits to a position on the board.\nulong red_pieces = 0; ulong yellow_pieces = 0; Now let’s assume the following board position:\nAs you can see in the above screenshot, yellow has won the game by placing 4 of their pieces vertically in a row.\nUsing a bitboard, we can check for a vertical win by utilizing the bitwise AND and bitshift operators as follows:\nulong pairs = yellow_pieces \u0026 (yellow_pieces 0) { return true; } else { return false; } First of all, we start by initializing a new bitboard, called pairs.\nThe goal of this bitboard is to store all of the vertical pairs of yellow coins, all the 2-in-a-row combinations.\nTo do this, we first bitshift all the yellow pieces left 1 bit – the upwards direction.\nAs you can see, bit 19 gets shifted to bit 20, bit 20 gets shifted to bit 21, bit 21 gets shifted to bit 22, and bit 22 gets shifted to bit 23.\nNow that we have shifted all of the pieces up by 1 tile, we record which pieces align with the initial yellow pieces. If they do align, then we have found 2 in a row.\nWe can do this by using the bitwise AND operator.\n/* *\t0 0 0 0 0 0 0\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t\u0026\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 0 0 0 0 */ // 000000000000000000001111000000000000000000 \u0026 000000000000000000011110000000000000000000 Bits 20, 21, and 22 are activated on both bitboards, so when we AND them together, those are the bits that will be left on.\n/* *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 */ // 000000000000000000001110000000000000000000 Since there are three activated bits, we can see that there were three pairs of vertical yellow pieces.\nNext, we’ll repeat the whole process again to find 4 in a row – with a slight tweak.\nThis time, we’re going to calculate a bitboard called quads – we’ll take the bitboard pairs that we just calculated and bitshift it left 2 bits. This is to find “pairs of pairs”, or 4 in a row.\n// 000000000000000000001110000000000000000000 Finally, we’ll AND the result with pairs . If there are any bits left on after this operation, we’ll know we have found four in a row.\n/* *\t0 0 0 1 0 0 0\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0\t\u0026\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0\t0 0 0 0 0 0 0 */ // 000000000000000000111000000000000000000000 \u0026 000000000000000000001110000000000000000000 Result:\n/* *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 1 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 *\t0 0 0 0 0 0 0 */ // 000000000000000000001000000000000000000000 1 bit (that corresponds to the topmost yellow piece) has been left activated - this means that there we have found four in a row.\nTo calculate four in a row in other directions too, we can just change the amount bitshifted. For example, we could calculate horizontal wins by bitshifting 6 bits to the left, instead of 1.\nUsing bitboards, we are able to calculate wins in connect 4 (and many other applications) without the use of many conditionals and using very low-level operations. This makes bitboards remarkably fast – good for an AI that needs to check for wins millions of times.\nBitboards can also be applied to more complex games like chess, where you can have a bitboard for each type of piece and color (i.e. A bitboard for white knights).\nCheck out my full Connect 4 AIand Othello AI.\n","wordCount":"1498","inLanguage":"en","datePublished":"2022-08-20T00:00:00Z","dateModified":"2022-08-20T00:00:00Z","author":{"@type":"Person","name":"Olin Johnson"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://olinjohnson.github.io/posts/optimizing-chess-othello-and-connect-4-with-bitboards/"},"publisher":{"@type":"Organization","name":"Olin Johnson","logo":{"@type":"ImageObject","url":"https://olinjohnson.github.io/favicon.ico"}}}</script></head><body id="
    top"><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://olinjohnson.github.io/ accesskey=h title="Olin Johnson (Alt + H)">Olin Johnson</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://olinjohnson.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://olinjohnson.github.io/about/ title=About><span>About</span></a></li><li><a href=https://olinjohnson.github.io/projects title=Projects><span>Projects</span></a></li><li><a href=https://olinjohnson.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://olinjohnson.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Optimizing Chess, Othello, and Connect 4 With Bitboards</h1><div class=post-description>Using bitboards to speed up move generation and evaluation</div><div class=post-meta><span title="2022-08-20 00:00:00 +0000 UTC">August 20, 2022</span>&nbsp;·&nbsp;Olin Johnson</div></header><div class=post-content><p>When creating an AI for games like chess and Othello, your move generation function is one of the most integral parts of the algorithm. However, often times, (if you’re not careful) it can also be one of the slowest parts of your AI, often greatly impacting performance after being executed over and over, millions of times. It is the chink in the impenetrable armor of your DIY supercomputer.</p><p>However, good news for you, there are significant optimizations we can make to drastically decrease the running time of your move generation function. One of the most influencing factors happens to be the way we represent the board.</p><p>Instead of representing the board with something like a 2d array, there’s a much more efficient data structure we can use: a bitboard.</p><p>Actually, multiple bitboards.</p><p>See, it turns out that it is very efficient to represent the board simply as a collection of large numbers. A bitboard is usually just a 64 bit integer, with each bit representing the corresponding tile on a board like a chess board. For example, In the game Othello, we might have 2 bitboards – 1 for black and another for white. Each “on” bit, or 1, in a bitboard represents an occupied tile, where a player’s piece is. Each “off” bit, or 0, represents an empty tile. This is why we have a bitboard for both black and white, to distinguish between each player’s pieces.</p><p>Defining a bitboard in C# can be as simple as declaring an unsigned (non-negative) long integer.</p><pre tabindex=0><code>ulong bitboard = 0;
</code></pre><p>In a game like Othello, we can also create a class for the game board with attributes to hold the bitboards for black and white.</p><pre tabindex=0><code>class Board
{
	ulong white_pieces = 0;
	ulong black_pieces = 0;

	public Board()
    	{
        	white_pieces = 0x1008000000;
        	black_pieces = 0x810000000;
    	}
}
</code></pre><p>Now, if we initialize a new <code>Board</code>, it will give us the starting position for an Othello game.</p><p><img loading=lazy src=/posts/bitboards/starting_board.png alt="Starting position for Othello"></p><p>You can see that if you convert the values for <code>white_pieces</code> and <code>black_pieces</code> from hexadecimal to binary, the activated bits in each bitboard will match up with the positions of the pieces on the board.</p><pre tabindex=0><code>ulong white_pieces = 0x1008000000;

/*
*	0x1008000000 = 0001000000001000000000000000000000000000
*
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 1 0 0 0 0
*	0 0 0 0 1 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*/
</code></pre><pre tabindex=0><code>ulong black_pieces = 0x810000000;

/*
*	0x810000000 = 100000010000000000000000000000000000
*
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 1 0 0 0
*	0 0 0 1 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*	0 0 0 0 0 0 0 0
*/
</code></pre><h3 id=why-use-bitboards>Why use bitboards?<a hidden class=anchor aria-hidden=true href=#why-use-bitboards>#</a></h3><p>Well, I can assure you, though bitboards seem like a lot of hassle initially, they are well worth it for their performance benefits.</p><p>The primary reason why bitboards are so computationally efficient is because you can utilize bitwise operators to speed up calculation and eleminate conditionals.</p><p>For example, in the game connect 4, in order to detect a win, we need to evaluate if either player has 4 in a row.</p><p>We can start by initializing two bitboards, one to keep track of the red player’s pieces and another to keep track of the yellow player’s pieces. Since a connect 4 board is smaller (only 42 tiles), we only need 42 bits to represent the board. So, we’ll assign each of the first 42 bits to a position on the board.</p><pre tabindex=0><code>ulong red_pieces = 0;
ulong yellow_pieces = 0;
</code></pre><p><img loading=lazy src=/posts/bitboards/assigned-bits.png alt="Bits assigned to board positions"></p><p>Now let’s assume the following board position:</p><p><img loading=lazy src=/posts/bitboards/yellow-win.png alt="A vertical win for yellow"></p><p>As you can see in the above screenshot, yellow has won the game by placing 4 of their pieces vertically in a row.</p><p>Using a bitboard, we can check for a vertical win by utilizing the bitwise AND and bitshift operators as follows:</p><pre tabindex=0><code>ulong pairs = yellow_pieces &amp; (yellow_pieces &lt;&lt; 1);
ulong quads = pairs &amp; (pairs &lt;&lt; 2);

if(quads &gt; 0)
{
	return true;
}
else
{
	return false;
}
</code></pre><p>First of all, we start by initializing a new bitboard, called <code>pairs</code>.</p><p>The goal of this bitboard is to store all of the vertical pairs of yellow coins, all the 2-in-a-row combinations.</p><p>To do this, we first bitshift all the yellow pieces left 1 bit – the upwards direction.</p><p><img loading=lazy src=/posts/bitboards/yellow_shifted.png alt="example of shifting"></p><p>As you can see, bit 19 gets shifted to bit 20, bit 20 gets shifted to bit 21, bit 21 gets shifted to bit 22, and bit 22 gets shifted to bit 23.</p><p>Now that we have shifted all of the pieces up by 1 tile, we record which pieces align with the initial yellow pieces. If they do align, then we have found 2 in a row.</p><p>We can do this by using the bitwise AND operator.</p><pre tabindex=0><code>/*
*	0 0 0 0 0 0 0				0 0 0 0 0 0 0
*	0 0 0 0 0 0 0				0 0 0 1 0 0 0
*	0 0 0 1 0 0 0				0 0 0 1 0 0 0
*	0 0 0 1 0 0 0		   &amp;		0 0 0 1 0 0 0
*	0 0 0 1 0 0 0				0 0 0 1 0 0 0
*	0 0 0 1 0 0 0				0 0 0 0 0 0 0
*/

// 000000000000000000001111000000000000000000 &amp; 000000000000000000011110000000000000000000
</code></pre><p>Bits 20, 21, and 22 are activated on both bitboards, so when we AND them together, those are the bits that will be left on.</p><pre tabindex=0><code>/*
*	0 0 0 0 0 0 0
*	0 0 0 0 0 0 0
*	0 0 0 1 0 0 0
*	0 0 0 1 0 0 0
*	0 0 0 1 0 0 0
*	0 0 0 0 0 0 0
*/

// 000000000000000000001110000000000000000000
</code></pre><p>Since there are three activated bits, we can see that there were three pairs of vertical yellow pieces.</p><p>Next, we’ll repeat the whole process again to find 4 in a row – with a slight tweak.</p><p>This time, we’re going to calculate a bitboard called <code>quads</code> – we’ll take the bitboard <code>pairs</code> that we just calculated and bitshift it left <strong>2 bits</strong>. This is to find “pairs of pairs”, or 4 in a row.</p><pre tabindex=0><code>// 000000000000000000001110000000000000000000 &lt;&lt; 2
/*
* 	Result:
*
*	0 0 0 1 0 0 0
*	0 0 0 1 0 0 0
*	0 0 0 1 0 0 0
*	0 0 0 0 0 0 0
*	0 0 0 0 0 0 0
*	0 0 0 0 0 0 0
*/

// 000000000000000000111000000000000000000000
</code></pre><p>Finally, we’ll AND the result with <code>pairs</code> . If there are any bits left on after this operation, we’ll know we have found four in a row.</p><pre tabindex=0><code>/*
*	0 0 0 1 0 0 0				0 0 0 0 0 0 0
*	0 0 0 1 0 0 0				0 0 0 0 0 0 0
*	0 0 0 1 0 0 0				0 0 0 1 0 0 0
*	0 0 0 0 0 0 0		   &amp;		0 0 0 1 0 0 0
*	0 0 0 0 0 0 0				0 0 0 1 0 0 0
*	0 0 0 0 0 0 0				0 0 0 0 0 0 0
*/

// 000000000000000000111000000000000000000000 &amp; 000000000000000000001110000000000000000000
</code></pre><p>Result:</p><pre tabindex=0><code>/*
*	0 0 0 0 0 0 0
*	0 0 0 0 0 0 0
*	0 0 0 1 0 0 0
*	0 0 0 0 0 0 0
*	0 0 0 0 0 0 0
*	0 0 0 0 0 0 0
*/

// 000000000000000000001000000000000000000000
</code></pre><p>1 bit (that corresponds to the topmost yellow piece) has been left activated - this means that there we have found four in a row.</p><p>To calculate four in a row in other directions too, we can just change the amount bitshifted. For example, we could calculate horizontal wins by bitshifting 6 bits to the left, instead of 1.</p><p>Using bitboards, we are able to calculate wins in connect 4 (and many other applications) without the use of many conditionals and using very low-level operations. This makes bitboards remarkably fast – good for an AI that needs to check for wins millions of times.</p><p>Bitboards can also be applied to more complex games like chess, where you can have a bitboard for each type of piece and color (i.e. A bitboard for white knights).</p><p>Check out my full <a href=https://github.com/olinjohnson/Connect4>Connect 4 AI</a> and <a href=https://github.com/olinjohnson/Othello>Othello AI</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://olinjohnson.github.io/posts/improving-minecrafts-ender-dragon-fight/><span class=title>Next »</span><br><span>Improving Minecraft's Ender Dragon Fight</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://olinjohnson.github.io/>Olin Johnson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>